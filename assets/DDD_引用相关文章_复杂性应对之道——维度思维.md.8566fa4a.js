import{_ as s,o as a,h as n,Q as e}from"./chunks/framework.79314373.js";const l="/assets/640-20240920215716553.f30e3496.webp",t="/assets/640-20240920215716597.9b09ead7.webp",p="/assets/640-20240920215716588.a357d6c6.webp",o="/assets/640-20240920215716626.47137ed7.webp",r="/assets/640-20240920215716596.43ff3f58.webp",c="/assets/640-20240920215716589.d1ba428a.webp",i="/assets/640-20240920215716627.5921fd52.webp",d="/assets/640.9c0a3c67.png",m="/assets/640-20240920215716647.6ff5c15d.webp",E="/assets/640-20240920215716661.5264f6f9.webp",h="/assets/640-20240920215716725.8478d1a0.webp",b="/assets/640-20240920215716684.98525c29.webp",y="/assets/640-20240920215716725.8478d1a0.webp",u="/assets/640-20240920215716728.956d1d9d.webp",g="/assets/640-20240920215716743.4ea3a9ef.webp",D=JSON.parse('{"title":"复杂性应对之道——维度思维 | PlantUml","description":"","frontmatter":{"title":"复杂性应对之道——维度思维","tags":[null,null],"head":[["meta",{"name":"keywords","content":"复杂性应对之道——维度思维 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客 | UML中国 | UML ｜ PlantUML ｜不止极客,nogeek,educode,教育编程,编程教育|Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://umlcn.com"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://umlcn.com/UmlCn-og.png"}],["meta",{"name":"og:title","content":"复杂性应对之道——维度思维 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客"}],["meta",{"name":"og:description","content":"复杂性应对之道——维度思维 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客 | 始于极客，不止极客｜educode｜educode.cn|nogeek|nogeek.cn｜CTO|架构师｜后端组长｜创业者｜高并发｜高性能｜高可用|技术合伙人｜架构咨询"}],["meta",{"name":"twitter:site","content":"https://umlcn.com"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"复杂性应对之道——维度思维 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客"}],["meta",{"name":"twitter:description","content":"复杂性应对之道——维度思维 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客 | 始于极客，不止极客｜educode｜educode.cn|nogeek|nogeek.cn｜CTO|架构师｜后端组长｜创业者｜高并发｜高性能｜高可用|技术合伙人｜架构咨询"}],["meta",{"name":"twitter:image","content":"https://umlcn.com/UmlCn-og.png"}],["meta",{"name":"baidu-site-verification","content":"codeva-E8fDj2NXib"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"DDD/引用相关文章/复杂性应对之道——维度思维.md","filePath":"DDD/引用相关文章/复杂性应对之道——维度思维.md","lastUpdated":1737644799000}'),_={name:"DDD/引用相关文章/复杂性应对之道——维度思维.md"},f=e('<blockquote><div class="info custom-block"><p class="custom-block-title">INFO</p><p>觉得本文讲的特别好，所以备份了一下</p><p>原文链接：<a href="https://mp.weixin.qq.com/s/nqVdLK98ccto0gQlr6MX6g" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/nqVdLK98ccto0gQlr6MX6g</a></p><p>原文公众号：从码农到工匠</p></div></blockquote><hr><div class="tip custom-block"><p class="custom-block-title">读者读后感</p><p><strong>读者点评：本文里边没表达清楚表格到底最后的横轴和纵轴到底是什么</strong></p><ul><li>一个维度应该是 <strong>业务用例图</strong> 中的 <strong>用例</strong>（例如：下单、付款）</li><li>一个维度应该是 <strong>业务用例图的用例</strong> 的 <strong>作用的对象</strong> 的 <strong>影响流程的属性特征</strong><ul><li>例如：（[<code>下单</code>]【业务用例图的用例]】的 [<code>手机</code>]【商品】的 [<code>发货位置</code>] [影响流程的属性特征]） <ul><li>手机的发货位置如果在 江浙沪，下单的 【物流处理相关流程】 是免运费的。其他是不免运费的。</li><li>【手机】的 【<code>颜色</code>】，不影响下单的处理流程。</li></ul></li></ul></li></ul><p>例子：</p><table><thead><tr><th></th><th>手机-江浙沪</th><th>手机-非江浙沪</th></tr></thead><tbody><tr><td>下单</td><td>第一步<br><br>第二步<br></td><td>第一步<br><br>第二步<br><br>第三步<br></td></tr><tr><td>付款</td><td>。。。</td><td>。。。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>如果影响流程的属性特别多，那么就应该正交结果，讲对象全部打平列举来做</p><p>如果，对象有两个属性</p><ul><li>【属性 1】有两个类别（a, b）</li><li>【属性 2】有两个类别（x, y）</li></ul><p>那么就有 四个情况（a-x, a-y、b-x, b-y)</p><table><thead><tr><th></th><th>对象【a-x】</th><th>对象【a-y】</th><th>对象【b-x】</th><th>对象【b-y】</th></tr></thead><tbody><tr><td>业务用例图-用例 1</td><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>业务用例图-用例 2</td><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>业务用例图-用例 3</td><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table><p>然后根据步骤类似的，用 <strong>多态扩展</strong> （复用流程编排）</p><p>步骤差别大的，用 .<strong>代码隔离</strong> （重写一套）</p></div><hr><blockquote><p>You should not be a if-else coder, should be a complexity conquer. -Frank</p></blockquote><p>这篇文章，是对之前我在《一文教会你如何写复杂业务代码》说的“自上而下的结构化分解 + 自下而上的抽象建模”方法论的升级。因为在之前的方法论中，我们缺少一个多维度看问题的视角，这种维度思维的缺失，可能会导致miss掉一些重要的业务信息，从而使我们制定软件设计策略的时候，陷入困难。</p><p>有了维度思维，我们便可以更加方面的去看清业务的全貌，更加全面的掌握业务信息，从而帮助我们更加体系化的去治理复杂性。</p><h2 id="从if-else说起" tabindex="-1">从if-else说起 <a class="header-anchor" href="#从if-else说起" aria-label="Permalink to &quot;从if-else说起&quot;">​</a></h2><p>我经常说，<strong>我们不要做一个if-else coder</strong>。这里的if-else，不是说我们在coding的时候不能使用if-else，而是说我们不应该简陋的用if-else去实现业务的分支流程，因为这样随意的代码堆砌很容易堆出一座座“屎山”。</p><p><strong>业务的差异性是if-else的根源</strong>。以零售通的商品业务为例。不同的处理场景，其业务逻辑实现是有差异性的。如下图所示，商品业务的差异性，主要体现在商品类型、销售方式和仓储方式的不同。</p><p><img src="'+l+`" alt="图片"></p><p>这三个维度上的差异组合起来，有2 * 3 * 2 = 12之多。这就是为什么在老代码中，到处可以看到 <code>if(组合品)blabla</code>， <code>if(赠品)blabla</code>， <code>if(实仓)blabla</code>之类的代码。</p><p>那么，要如何消除这些讨厌的if-else呢？我们可以考虑以下两种方式：</p><ul><li>多态扩展：利用面向对象的多态特性，实现代码的复用和扩展。</li><li>代码分离：对不同的场景，使用不同的流程代码实现。这样很清晰，但是可维护性不好。</li></ul><h3 id="多态扩展" tabindex="-1">多态扩展 <a class="header-anchor" href="#多态扩展" aria-label="Permalink to &quot;多态扩展&quot;">​</a></h3><p>多态扩展可以有继承和组合两种方式。继承勿用多言，组合有点像策略模式，也就是把需要扩展的部分封装、抽象成需要被组合的对象，然后对其进行扩展，比如星环的能力扩展点就是这种方式。</p><p>这里，我们举一个继承的例子，商品在上架的时候要检查商品的状态是否可售，普通商品（Item）检查自己就好了，而组合商品（CombineItem）需要检查每一个子商品。</p><p>用过程式编码的方式，很容易就能写出如下的代码：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">checkSellable</span><span style="color:#E1E4E8;">(Item item){    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (item.</span><span style="color:#B392F0;">isNormal</span><span style="color:#E1E4E8;">()){        </span></span>
<span class="line"><span style="color:#E1E4E8;">        item.</span><span style="color:#B392F0;">isSellable</span><span style="color:#E1E4E8;">();         </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//省略异常处理    </span></span>
<span class="line"><span style="color:#E1E4E8;">    }    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {        </span></span>
<span class="line"><span style="color:#E1E4E8;">        List&lt;</span><span style="color:#F97583;">Item</span><span style="color:#E1E4E8;">&gt; childItems </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getChildItems</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        childItems.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(childItem </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> childItem.</span><span style="color:#B392F0;">isSellable</span><span style="color:#E1E4E8;">());         </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//省略异常处理    </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">checkSellable</span><span style="color:#24292E;">(Item item){    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (item.</span><span style="color:#6F42C1;">isNormal</span><span style="color:#24292E;">()){        </span></span>
<span class="line"><span style="color:#24292E;">        item.</span><span style="color:#6F42C1;">isSellable</span><span style="color:#24292E;">();         </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//省略异常处理    </span></span>
<span class="line"><span style="color:#24292E;">    }    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {        </span></span>
<span class="line"><span style="color:#24292E;">        List&lt;</span><span style="color:#D73A49;">Item</span><span style="color:#24292E;">&gt; childItems </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getChildItems</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        childItems.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(childItem </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> childItem.</span><span style="color:#6F42C1;">isSellable</span><span style="color:#24292E;">());         </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//省略异常处理    </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>然而，这个实现不优雅，不满足OCP，也缺少业务语义显性化的表达。更好的做法是，我们可以把CombineItem和Item的关系通过模型显性化的表达出来。</p><p><img src="`+t+`" alt="图片"></p><p>这样一来，一方面模型正确的反应了实体关系，更清晰了。另一方面，我们可以利用多态来处理CombineItem和Item的差异，扩展性更好。重构后，代码会变成：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">checkSellable</span><span style="color:#E1E4E8;">(Item item) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">item.</span><span style="color:#B392F0;">isSellable</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BizException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;商品的状态不可售，不能上架&quot;</span><span style="color:#E1E4E8;">)；</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">checkSellable</span><span style="color:#24292E;">(Item item) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">item.</span><span style="color:#6F42C1;">isSellable</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BizException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;商品的状态不可售，不能上架&quot;</span><span style="color:#24292E;">)；</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="代码分离" tabindex="-1">代码分离 <a class="header-anchor" href="#代码分离" aria-label="Permalink to &quot;代码分离&quot;">​</a></h3><p>所谓的代码分离是指，对于不同的业务场景，我们用不同的编排代码将他们分开。以商品上架为例，我们可以这样写：</p><p><img src="`+p+'" alt="图片"></p><p>这种方式，当然也可以消除if-else，彼此独立，也还清晰。但复用性是个问题。</p><h3 id="多维分析" tabindex="-1">多维分析 <a class="header-anchor" href="#多维分析" aria-label="Permalink to &quot;多维分析&quot;">​</a></h3><p>细心的你可能已经发现了，在上面的案例中，普通商品和组合商品的业务流程基本是一样的。如果采用两套编排代码，有点冗余，这种重复将不利于后期代码的维护，会出现散弹式修改（一个业务逻辑要修改多处）的问题。</p><p>一个极端情况是，假如普通商品和组合商品，只有 <code>checkSellable()</code>不一样，其它都一样。那毫无疑问，我们使用有多态（继承关系）的CombineItem和Item来处理差异，会更加合适。</p><p>而赠品上架的情况恰恰相反，它和其他商品的上架流程差异很大。反而不适合和他们合用一套流程代码，因为这样反而会增加他人的理解成本。还不如单独起一个流程来的清晰。</p><p>那么，问题来了，我们什么时候要用多态来处理差异，什么时候要用代码分离来处理差异呢？</p><p><strong>接下来，是我今天要给你着重介绍的多维度分析问题的方法论之一：矩阵分析法</strong>。</p><p>我们可以弄一个矩阵，纵列代表业务场景，横列代表业务动作，里面的内容代表在这个业务场景下的业务动作的详细业务流程。对于我们的商品业务，我们可以得到如下的矩阵：</p><p><img src="'+o+'" alt="图片"></p><p>通过上面的矩阵分析，我们不难看出普通品和组合品可以复用同一套流程编排代码，而赠品和出清品的业务相对简单，更适合有一套独立的编排代码，这样的代码结构会更容易理解。</p><h2 id="维度思维" tabindex="-1">维度思维 <a class="header-anchor" href="#维度思维" aria-label="Permalink to &quot;维度思维&quot;">​</a></h2><h3 id="多维度的重要性" tabindex="-1">多维度的重要性 <a class="header-anchor" href="#多维度的重要性" aria-label="Permalink to &quot;多维度的重要性&quot;">​</a></h3><p>上面的案例不是我编造出来的，而是我在和张文（我同事）讨论应该用哪种方式去处理业务差异的真实故事。</p><p>我记得在和大学讨论完，开车回去的路上，我一直在想这个问题，然后在第二个路口等红灯的时候，突然有一个灵感冒出来。我抑制不住兴奋，一边开车，一边发消息给张文说：“我想到了一个很NB的方法论，能解决在‘多态扩展’和‘代码分离’之间如何做选择的问题”。</p><p>其实，我知道我兴奋的不仅仅是解决了这个问题。<strong>我兴奋的是，我第一次真正领悟到了多维度思考的重要性。从而有机会从一个“单维度”生物，升级成一个“多维度”思考者</strong>。妈妈再也不用担心我被“降维打击”了：）</p><p>结构化思维有用、很有用、非常有用，只是它更多关注的是单向维度的事情。比如我要拆解业务流程，我要分解老板给我的工作安排，我要梳理测试用例，都是单向维度的。</p><p>而复杂性，通常不仅仅是一个维度上的复杂，而是在多个维度上的交叉复杂性。当问题涉及的要素比较多，彼此关联关系很复杂的时候，两个维度肯定会比一个维度要来的清晰，<strong>这也是为什么说矩阵思维是比结构化思维更高层次的思维方式</strong>。</p><p>实际上，我们从汉语的词汇上，也不难看出一个人的思维层级，是和他的思考维度正相关的。<strong>当我们说这个人很“轴”、“一根筋”的时候，实际上是在说他只有一维的线性思维</strong>。所以，观察事物的视角越多，维度越丰富，其思维层级也会越高。</p><p><img src="'+r+'" alt="图片"></p><h3 id="无处不在的多维思考" tabindex="-1">无处不在的多维思考 <a class="header-anchor" href="#无处不在的多维思考" aria-label="Permalink to &quot;无处不在的多维思考&quot;">​</a></h3><p>有了这些感悟，我开始系统的整理关于多维度思考分析的资料，发现这种思考方式真是无处不在。发现的越多，我越是感慨，为什么如此重要的思维方式，我到现在才领悟到。</p><h4 id="波士顿矩阵" tabindex="-1">波士顿矩阵 <a class="header-anchor" href="#波士顿矩阵" aria-label="Permalink to &quot;波士顿矩阵&quot;">​</a></h4><p>比如，在做产品分析的时候，有对产品发展前景进行分析的波士顿矩阵。</p><p><img src="'+c+'" alt="图片"></p><h4 id="订单要素分析" tabindex="-1">订单要素分析 <a class="header-anchor" href="#订单要素分析" aria-label="Permalink to &quot;订单要素分析&quot;">​</a></h4><p>当年，我在1688做交易下单业务的时候，有非常多的下单场景，每种场景下，买家享受的权益是不一样的（如下表所示）。我们当时也是使用了矩阵去表达这个复杂的关系，只是当时还没有想到要将其提升到方法论的高度。</p><p><img src="'+i+'" alt="图片"></p><h4 id="数据交叉分析" tabindex="-1">数据交叉分析 <a class="header-anchor" href="#数据交叉分析" aria-label="Permalink to &quot;数据交叉分析&quot;">​</a></h4><p>在数据分析中，维度分析是非常重要的，特别是维度很多的时候，我们可以通过皮尔逊积矩相关系数，做交叉分析，从而弥补独立维度分析没法发现的一些问题。</p><p><img src="'+d+'" alt="图片"></p><h4 id="分析矩阵" tabindex="-1">分析矩阵 <a class="header-anchor" href="#分析矩阵" aria-label="Permalink to &quot;分析矩阵&quot;">​</a></h4><p>最近我碰巧看到Alan Shalloway写的《设计模式解析：Design Patterns Explained》，这是一本非常经典的关于OOP的书，里面的第十六章就是专门讲“分析矩阵”的，作者创造这个方法论的初衷也是因为业务涉及的要素太多，信息量太大，他需要一种组织海量数据的新方式。</p><p><img src="'+m+'" alt="图片"></p><p>我和Alan的路径不一样，但是都得出了同样的结论。由此可见，<strong>这种矩阵分析的方式的确是对复杂业务进行分析的一把利器，业务场景越多，交叉关系越是复杂，越需要这样的分析</strong>。</p><h4 id="组织阵型" tabindex="-1">组织阵型 <a class="header-anchor" href="#组织阵型" aria-label="Permalink to &quot;组织阵型&quot;">​</a></h4><p>生产关系决定生产力，对于一个管理者来说，如何有效的设置组织结构是决定团队是否能高效协作的关键。所以我们可以看到公司里面，每年都有比较大的关于组织结构和人员安排的调整。</p><p>对于技术团队来说，我们习惯于按领域划分工作范围，这样做的好处是责任到人、职责清晰。然而，领域只是一个维度，我们工作通常都是以项目的形式的开展，而项目通常是贯穿多个领域的。所以，在做团队组织规划的时候，我们可以通过业务领域和业务项目两个维度去看。</p><p>比如，在我负责的商品团队，我会按照如下的形式去做职责划分。</p><p><img src="'+E+'" alt="图片"></p><h4 id="时间维度" tabindex="-1">时间维度 <a class="header-anchor" href="#时间维度" aria-label="Permalink to &quot;时间维度&quot;">​</a></h4><p>除了工作，生活中也到处可见多维思考的重要性。</p><p>比如，我们说浪费可耻，应该把盘子舔的很干净，岂不知加上时间维度之后，你当前的舔盘，后面可能要耗费更多的资源和精力去减肥，反而会造成更大的浪费。</p><p>我们说代码写的丑陋，是因为要“快速”支撑业务，加上时间维度之后，这种临时的妥协，换来的是意想不到的bug，线上故障，以及无止尽的996。</p><h4 id="rfm模型" tabindex="-1">RFM模型 <a class="header-anchor" href="#rfm模型" aria-label="Permalink to &quot;RFM模型&quot;">​</a></h4><p>简单的思考是“点”状的，比如舔盘、代码堆砌就是当下的“点”；好一点的思考是“线”状，加上时间线之后，不难看出“点”是有问题的；再全面一些的思考是“面”（二维）；更体系化的思考是“体”（三维）；比如，RFM模型就是一个很不错的三维模型。可惜的是，在表达上，我们人类只能在二维的空间里去模拟三维，否则四维可能会更加有用。</p><p><img src="'+h+'" alt="图片"></p><h2 id="复杂业务治理总结" tabindex="-1">复杂业务治理总结 <a class="header-anchor" href="#复杂业务治理总结" aria-label="Permalink to &quot;复杂业务治理总结&quot;">​</a></h2><p>在前言部分，我已经说过了，多维分析是对之前方法论的升级。加上以前的方法论，<strong>完整的方法论应该是“业务理解--&gt;领域建模--&gt;流程分解--&gt;多维分析”</strong>。</p><p>为了方便大家理解，下面我把这些方法论做一个简单的串联和解释。</p><h3 id="业务理解" tabindex="-1">业务理解 <a class="header-anchor" href="#业务理解" aria-label="Permalink to &quot;业务理解&quot;">​</a></h3><p>理解业务是所有工作的起点。首先，我们要找到业务的核心要素，理解核心概念，梳理业务流程。</p><p>比如，在零售通的商品域，我们要知道什么是商品（Item），什么是单品（CSPU），什么是组合品（CombineItem）。在下单域，我们要知道订单（order）的构成要素是商品、优惠、支付。在CRM领域，我们要理解客户、机会、联系人、Leads等等。</p><p>这里，我想再次强调下语言的重要性，语言是我们思考的载体，就像维特根斯坦说的：“<strong>凡是能够说的事情，都能够说清楚</strong>”</p><p>你不应该放过任何一个模糊的业务概念，一定要透彻的理解它，并给与合理的命名（Ubiquitous Language）。唯有如此，我们才能更加清晰的理解业务，才能更好的开展后续的工作。</p><h3 id="领域建模" tabindex="-1">领域建模 <a class="header-anchor" href="#领域建模" aria-label="Permalink to &quot;领域建模&quot;">​</a></h3><p>在软件设计中，模型是指实体，以及实体之间的联系，这里需要我们具备良好的抽象能力。能够透过庞杂的表象，找到事务的本质核心。</p><p>再复杂的业务领域，其核心概念都不应该太复杂，抓住了核心，我们就抓住了主线，业务往往都是围绕着这些核心实体展开的。</p><p>比如，商品域虽然很复杂，但其核心的领域模型，无外乎就如下图所示：</p><p><img src="'+b+'" alt="图片"></p><h3 id="流程分解" tabindex="-1">流程分解 <a class="header-anchor" href="#流程分解" aria-label="Permalink to &quot;流程分解&quot;">​</a></h3><p>关于流程分解，在《一文教会你如何写复杂业务代码》里面已经有非常详细的阐述，这里就不赘述了。</p><p>简单来说，<strong>流程分解就是对业务过程进行详细的分解，使用结构化的方法论（先演绎、后归纳），最后形成一个金字塔结构</strong>。</p><p>比如，在商品领域，有创建商品、商品上架、上架审核、商品下架、下架审核、修改商品、删除商品等一些列动作（流程），每个动作的背后都有非常复杂的业务逻辑。我们需要对这些流程进行详细的梳理，然后按步骤进行分解。最后形成一个如下的金字塔结构：</p><p><img src="'+y+'" alt="图片"></p><h3 id="多维分析-1" tabindex="-1">多维分析 <a class="header-anchor" href="#多维分析-1" aria-label="Permalink to &quot;多维分析&quot;">​</a></h3><p>关于多维分析，我以二维的矩阵分析为例，我想我前面应该已经说清楚了。</p><p>业务的复杂性主要体现在流程的复杂性和多维度要素相互关联、依赖关系上，结构化思维可以帮我们梳理流程，而矩阵思维可以帮忙我们梳理、呈现多维度关联、依赖关系。二者结合，可以更加全面的展现复杂业务的全貌。从而让我们的治理可以有的放矢、有章可循。</p><p>既然是方法论，在这里，我会尝试给出一个矩阵分析的框架。试想下，如果我们的业务很简单，只有一个业务场景，没有分支流程。我们的系统不会太复杂。之所以复杂，是因为各种业务场景互相叠加、依赖、影响。</p><p>因此，<strong>我们在做矩阵分析的时候，纵轴可以选择使用业务场景，横轴是备选维度</strong>，可以是受场景影响的业务流程（如文章中的商品流程矩阵图），也可以是受场景影响的业务属性（如文章中的订单组成要素矩阵图），或者任何其它不同性质的“东西”。</p><p><img src="'+u+'" alt="图片"></p><p>通过矩阵图，可以清晰的展现不同场景下，业务的差异性。基于此，我们可以定制满足差异性的最佳实现策略，可能是多态扩展，可能是分离的代码，也可能是其它。</p><p><strong>这就是矩阵分析的要义，其本质是一种多维度思考的方法论</strong>。</p><h2 id="篇后寄语" tabindex="-1">篇后寄语 <a class="header-anchor" href="#篇后寄语" aria-label="Permalink to &quot;篇后寄语&quot;">​</a></h2><p>最后，我想说世界是熵增的（即万物都在缓慢的分崩离析），控制复杂度是我们这些从业者无法推卸的责任和使命。</p><p>软件行业的发展才几十年，还是一门年轻的学科，<strong>软件工程就像一个刚学会走路的小孩，还很不成熟，有时还很幼稚</strong>。</p><p>但毕竟还是有几十年的沉淀，还是有一些好的方法和实践可以参考，我的这些总结沉淀只是在前人的基础上，多走了一点点而已。但就是这一点点，也实属来自不易，其中冷暖，只有自己能体会。可以说，这一路走来，是一场对心力、脑力和体力的持续考验。</p><p><img src="'+g+'" alt="图片"></p><ul><li>心力是指不将就的匠心，不妥协的决心，不满足的好奇心、以及不放弃的恒心。</li><li>脑力是指那些必要的思维能力、学习能力、思考能力、思辨能力。</li><li>之所以说“业务理解--&gt;领域建模--&gt;流程分解--&gt;多维分析”是体力，<strong>是因为实现它们就像是在做填空题，只要你愿意花时间，再复杂的业务都可以按部就班的清晰起来</strong>。</li></ul><p>梳理清晰了，再配合COLA（<a href="https://start.aliyun.com/%EF%BC%89%E7%9A%84%E6%8C%87%E5%AF%BC%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E6%9C%89%E5%8F%AF%E8%83%BD%E5%86%99%E5%87%BA%E6%B8%85%E6%99%B0%E3%80%81%E6%98%93%E8%AF%BB%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%B0%B1%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BB%8E%E4%B8%80%E4%B8%AAif-else" target="_blank" rel="noreferrer">https://start.aliyun.com/）的指导，我们就有可能写出清晰、易读的代码，就有可能从一个if-else</a> coder升级为一个complexity conquer。</p><p>而这不正是我们工程师孜孜不倦的追求吗?</p>',106),k=[f];function q(F,C,P,B,A,x){return a(),n("div",null,k)}const w=s(_,[["render",q]]);export{D as __pageData,w as default};
