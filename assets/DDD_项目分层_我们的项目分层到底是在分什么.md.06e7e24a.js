import{_ as e,o as t,h as a,Q as r}from"./chunks/framework.79314373.js";const o="/assets/简洁灵活的多模块项目分层.32cede8c.svg",u=JSON.parse('{"title":"我们的项目分层到底是在分什么 | PlantUml","description":"","frontmatter":{"title":"我们的项目分层到底是在分什么","tags":[null,null],"head":[["link",{"rel":"canonical","href":"https://umlcn.com/DDD/项目分层/我们的项目分层到底是在分什么.html"}],["meta",{"name":"keywords","content":"我们的项目分层到底是在分什么 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客 | UML中国 | UML ｜ PlantUML ｜不止极客,nogeek,educode,教育编程,编程教育|Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://umlcn.com"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://umlcn.com/UmlCn-og.png"}],["meta",{"name":"og:title","content":"我们的项目分层到底是在分什么 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客"}],["meta",{"name":"og:description","content":"我们的项目分层到底是在分什么 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客 | 始于极客，不止极客｜educode｜educode.cn|nogeek|nogeek.cn｜CTO|架构师｜后端组长｜创业者｜高并发｜高性能｜高可用|技术合伙人｜架构咨询"}],["meta",{"name":"twitter:site","content":"https://umlcn.com"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"我们的项目分层到底是在分什么 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客"}],["meta",{"name":"twitter:description","content":"我们的项目分层到底是在分什么 | PlantUml | PlantUml | UMLCn ｜ 软件方法 | NoGeek ｜不止极客 | 始于极客，不止极客｜educode｜educode.cn|nogeek|nogeek.cn｜CTO|架构师｜后端组长｜创业者｜高并发｜高性能｜高可用|技术合伙人｜架构咨询"}],["meta",{"name":"twitter:image","content":"https://umlcn.com/UmlCn-og.png"}],["meta",{"name":"baidu-site-verification","content":"codeva-E8fDj2NXib"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"DDD/项目分层/我们的项目分层到底是在分什么.md","filePath":"DDD/项目分层/我们的项目分层到底是在分什么.md","lastUpdated":1740372378000}'),l={name:"DDD/项目分层/我们的项目分层到底是在分什么.md"},i=r('<div class="tip custom-block"><p class="custom-block-title">核心观点：</p><p><strong>一、无论是 MVC 的分层，还是 DDD 的分层，本质是因为职责不同，职责不同体现的是，方法的内容不同。方法的内容就是职责，代表 <code>做了哪些事情</code> ，而所做的事情，才是我们重点关注的东西。</strong></p><p><strong>二、至于有的公司强制，定义的 Request，再加上 VO，DTO，DO，再加上，Domain，完全是无能的管理者的无效的过度管理的产物。至于为什么，我后边会解释，为什么叫无能的管理者的无效的过度管理的产物。</strong></p><ul><li>无能的管理者，是不知道项目分层的本质是职责的不同</li><li>无效的过度管理，是说这么多乱碰碰的定义是没有无效的过度管理</li></ul><p><strong>三、罗永浩说的一句话是对的：这个世界是一般中年人掌握的世界，他不只有制定规则的权利，还有解释规则的权利。</strong></p></div><hr><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>我曾经和别人讨论过一个问题，就是，我的 <code>接口Request</code> 在 <code>持久层</code> (DAO) 能不能引用到？</p><ul><li>我的结论是可以引用。</li></ul><h2 id="讨论项目分层" tabindex="-1">讨论项目分层 <a class="header-anchor" href="#讨论项目分层" aria-label="Permalink to &quot;讨论项目分层&quot;">​</a></h2><h3 id="查看维基百科的mvc" tabindex="-1">查看维基百科的MVC <a class="header-anchor" href="#查看维基百科的mvc" aria-label="Permalink to &quot;查看维基百科的MVC&quot;">​</a></h3><p>先说，MVC 分层是什么：我特意去查询了 维基百科关于 MVC 的解释： <a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noreferrer">https://zh.wikipedia.org/wiki/MVC</a></p><blockquote><p><strong>引用来自维基百科</strong></p><p>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><p>。。。</p><ul><li>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</li><li>视图（View） - 界面设计人员进行图形界面设计。</li><li>控制器（Controller）- 负责转发请求，对请求进行处理。</li></ul><p>实际范例</p><p>这里有一个通过 <a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noreferrer">JavaScript</a> 所实现的基于 MVC 模型，需要注意的是：MVC 不是一种技术，而是一种理念。</p><p><a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noreferrer">Java</a></p><p><a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noreferrer">Java</a> 平台企业版 (J2EE)</p><p>和其他的各种框架不一样，J2EE为模型对象（Model Objects）定义了一个规范。</p><ul><li><p>视图(View)</p><p>在J2EE应用程序中，视图（View）可能由Java Server Page(JSP)担任。生成 View 的代码则可能是一个<a href="https://zh.wikipedia.org/wiki/Servlet" target="_blank" rel="noreferrer">servlet</a>的一部分，特别是在客户端服务端交互的时候。</p></li><li><p>控制器（Controller）</p><p><a href="https://zh.wikipedia.org/wiki/J2EE" target="_blank" rel="noreferrer">J2EE</a>应用中，Controller 可能是一个<a href="https://zh.wikipedia.org/wiki/Servlet" target="_blank" rel="noreferrer">servlet</a>。</p><p>除了可直接以J2EE来撰写外，亦可用其他框架来撰写，常见的有<a href="https://zh.wikipedia.org/wiki/Struts2" target="_blank" rel="noreferrer">Struts2</a>、<a href="https://zh.wikipedia.org/wiki/Spring_Framework" target="_blank" rel="noreferrer">Spring Framework</a>……等等。</p></li><li><p>模型（Model）</p><p>Model 则是由一个<a href="https://zh.wikipedia.org/wiki/JavaBean" target="_blank" rel="noreferrer">实体Bean</a>来实现。</p></li></ul><p>Java <a href="https://zh.wikipedia.org/wiki/Swing_(Java)" target="_blank" rel="noreferrer">Swing</a></p><p>Swing是一个标准的MVC结构。ComponentUI代表View，负责描画组件。组件尤其Model层，比如JTextField的Document、JTable的TableModel、JTree的TreeModel等等。Control可能不是很明显，我们可以将Event机制看作Swing团队为开发者设计的Controller。</p><p>作为Java开发者，如果想理解MVC的结构，学习Swing的确是个不错的选择。</p></blockquote><hr><p>仔细阅读：维基百科对 MVC 的解释，发现了没有，其实，对我们 JAVA 开发人员来说，其实我们经常接触到的 MVC 也就是 Spring MVC 的 Controller 。</p><ul><li><code>M</code> 就是 我们的 controller 方法里的 参数和返回值</li><li><code>V</code> 在前后分离的项目中已经被前端给承接走了</li><li><code>C</code> 就是我们 controller 的一个方法</li></ul><h4 id="结论-mvc-并没有说我们的-controller、service、dao-的分层" tabindex="-1">结论：MVC 并没有说我们的 Controller、Service、Dao 的分层 <a class="header-anchor" href="#结论-mvc-并没有说我们的-controller、service、dao-的分层" aria-label="Permalink to &quot;结论：MVC 并没有说我们的 Controller、Service、Dao 的分层&quot;">​</a></h4><hr><h3 id="查看维基百科的-ddd" tabindex="-1">查看维基百科的 DDD <a class="header-anchor" href="#查看维基百科的-ddd" aria-label="Permalink to &quot;查看维基百科的 DDD&quot;">​</a></h3><p>关于 <code>DDD</code> 是 <code>领域驱动设计</code> 的简称：所以在维基百科上，我们查询 <code>领域驱动设计</code> 链接：<a href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88" target="_blank" rel="noreferrer">https://zh.wikipedia.org/wiki/領域驅動設計</a></p><blockquote><p>Repository</p><p>对于检索特定域对象的方法应该委派给 Repository 对象，因为这样可以很容易地互换替代存储的实现</p><p>Service</p><p>强调与其他对象的关系，只定义了可以为客户做什么，不应该替代 Entity 和 Value Object 的所有行为</p></blockquote><p>发现了没有，维基百科对 DDD 的定义，也没有说我的 Repository 的参数必须在我 Repository 层去定义，也没有说，我的 Service 的参数必须在我 Service 层去定义。</p><h4 id="结论-ddd-也没有说我们的每层的参数必须单独的定义。" tabindex="-1">结论：DDD 也没有说我们的每层的参数必须单独的定义。 <a class="header-anchor" href="#结论-ddd-也没有说我们的每层的参数必须单独的定义。" aria-label="Permalink to &quot;结论：DDD 也没有说我们的每层的参数必须单独的定义。&quot;">​</a></h4><h3 id="猜测-controller、service、dao-的由来" tabindex="-1">猜测 Controller、Service、DAO 的由来 <a class="header-anchor" href="#猜测-controller、service、dao-的由来" aria-label="Permalink to &quot;猜测 Controller、Service、DAO 的由来&quot;">​</a></h3><p>其实，我们在学习 JAVA 的时候，一般先学 语法、然后是面向对象、然后是，数据库操作，最后就是搞一个 <code>MVC项目</code> 玩一玩了。</p><p>其实，我们再重新看一下我们的所谓的 <code>MVC项目</code> 的分层到底做了哪些事情。</p><ul><li>Controller：处理请求转发</li><li>Service：处理业务逻辑</li><li>DAO：处理持久化操作</li></ul><p>仔细思考我说的话，他们的分层根本原因是处理的职责不同。职责不同，是因为他们所对应的方法的参数不同。</p><h3 id="项目分层的本质" tabindex="-1">项目分层的本质 <a class="header-anchor" href="#项目分层的本质" aria-label="Permalink to &quot;项目分层的本质&quot;">​</a></h3><p><strong>职责就是做了哪些事情，这个做了哪些事情，本质就是，方法的内容是怎么写的。</strong></p><hr><p>究竟是什么时候，有了，Query、Request、Response、VO、DTO、DO 的区别了呢？好像突然就流行了？</p><blockquote><p><strong>罗永浩说的一句话是对的：这个世界是一般中年人掌握的世界，他不只有制定规则的权利，还有解释规则的权利。</strong></p></blockquote><p>其实，他说不出来为什么，但是他就想这么做。如果他即使讲不清楚为什么的时候，或者说，你真的讲到了他的知识盲区了。</p><p>他就会跟你说一句话：“我是你的上级，你应该服从我。”这才是很多软件项目 半生坎坷、折戟沉沙的根本原因。</p><blockquote><p>在我的多年的最佳实践中，DO 是必须的，Request、Repsonse 是必须的（而且，每个接口都需要有独立的 Request、Response，不能共享）。至于其他的什么 VO、DTO 都不是必须的。</p></blockquote><h3 id="那复杂的业务逻辑应该怎么做" tabindex="-1">那复杂的业务逻辑应该怎么做？ <a class="header-anchor" href="#那复杂的业务逻辑应该怎么做" aria-label="Permalink to &quot;那复杂的业务逻辑应该怎么做？&quot;">​</a></h3><p><strong>业务逻辑的处理流程的编排是另外一个问题：</strong></p><p>可以看我引用的关于 <a href="https://umlcn.com/DDD/%E5%BC%95%E7%94%A8%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/%E4%B8%80%E6%96%87%E6%95%99%E4%BC%9A%E4%BD%A0%E5%A6%82%E4%BD%95%E5%86%99%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%9A%84%E4%BB%A3%E7%A0%81" target="_blank" rel="noreferrer">一文教会你如何写复杂业务的代码</a> 基于过程分解就可以解决 80% 的问题。</p><p>这个跟参数定义也没有关系。</p><p>所以，回到我最初的问题，至于，别人为了反驳我而讲的，什么 因为 DDD、MVC 是站不住脚的。**至于，项目分层是因为，处理的对应逻辑职责不同。**这句话，其实很多人都理解不到。</p><p>这句话，理解不了，我认为他很无能。至于说无效呢？那就是，你定义了很多 DTO，VO，依然没有你觉你 <code>业务逻辑</code> 的复杂性的问题。</p><p>业务逻辑的代码，我认为有三个点很重要：</p><ol><li>可读性</li><li>扩展性</li><li>开发效率</li></ol><p><strong>这个并不是定义一个 DAO 的 Query 就可以解决的。</strong> 所以我说这是一个无效的管理措施。</p><p>这里分享一下，我曾经负责过的 50 个微服务的量级的项目分层怎么做的：</p><h3 id="最佳实践是什么" tabindex="-1">最佳实践是什么 <a class="header-anchor" href="#最佳实践是什么" aria-label="Permalink to &quot;最佳实践是什么&quot;">​</a></h3><p>其实最重要的还是，把其中的依赖管理给做好，比如，Web 层引用不到 <code>@Table</code> 之类的持久层注解，<code>Dao</code> 层，引用不到 <code>manager</code> 层的类定义。如果这个做不到，那么工程结构就是一团乱麻。</p><p>可以关注我，回头，我可以分享，这一套如何用</p><ul><li><strong>微服务架构怎么做?</strong></li><li><strong>DDD 架构怎么做？</strong></li></ul><p><img src="'+o+'" alt="简洁灵活的多模块项目分层"></p>',47),n=[i];function p(c,d,s,h,m,g){return t(),a("div",null,n)}const D=e(l,[["render",p]]);export{u as __pageData,D as default};
